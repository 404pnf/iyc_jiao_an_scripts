# -*- coding: utf-8 -*-
require 'fileutils'
require 'minitest/autorun'

# usage: script.rb inputfolder outputfolder

$input = File.expand_path(ARGV[0].chomp('/'))
# 我只想对绝对目录的最后一个目录进行sanitize
# 我只会用这种笨方法 ^_^
$char_count_of_higher_path = $input.size
* 近期消费
** DONE 化妆品等 $144.34
Order Number: 111-0441114-3371440
Recipient: Van Tran, Esq.
 Clarins Body Treatment Oil, Firming, Toning, 3.4-Ounce Box
 2 of The Body Shop Vitamin E Sink-In Moisture Mask, 3.3-Ounce
 LEGO Walkie Talkies
 Great Explorations Celestial Super Kits - Wonder Stars Super Kit
 Hal Leonard Bass Method - Complete Edition: Books 1, 2 and 3 Bound Together in One Easy-to-Use Volume!
 The Body Shop Vitamin E Moisture Cream, 1.7-Fluid Ounce
** TODO glw 域名 3年 40美元 +  服务器费用 15美元 没有给我近期托老孟带给我
** DONE 我的域名续费 86美元
rijiben.org
ziyouruanjian.org
ziyouwenhua.org
diantai.us
hcwdxx.com
tongnian.org
** DONE 电子表和我的维 生素 132美元
 2 of Casio Men's W800H-1AV Classic Digital Sport Watch
 LIFE Jubilee! Queen Elizabeth II: 60 Years on the Throne
 Nature Made Prenatal Multi Vitamin Value Size, Tablets, 250-Count
 New Chapter Perfect Prenatal, 96 Count
 2 of Panasonic RPHJE120V In-Ear Headphone, Violet
 Quikclot Sport Brand Advanced Clotting Sponge ,Stop Bleeding Fast, 50 Gram Package
** DONE kindle 杂志和电子书 90
近半年的杂志和十几本书
** DONE audible 40美元

** DONE lina维生素 68美元  已经给我人民币了 445元
** 以上共计： 乘以 6.5 合计4045 实际给 4100
$output = File.expand_path(ARGV[1].chomp('/'))
def sanitize(title)
  # 不要替换 / 否则路径分割符号也被替换了
  # 因为下面的file是含有路径的
  # 也不要替换英文句号，因为作为文件后缀分割符号
  # 例子： "source//TLF/PBS自由选择/PBS.自由选择_2_/_PBS自由选择_PBS.Free_to_Choose_1990.Vol.4"
  title = title.tr(' `~!@#$%^&*()_+=\|][{}"\';:>,<-', '_')
  title = title.tr('？ －·～！@#￥%……&*（）——+、|】』【『‘“”；：。》，《', '_')
  title = title.gsub(/_+/, '_').gsub(/^_/, '').gsub(/_$/, '') # 对开头，结尾和多个 _ 做处理
  title = title.gsub('_/', '/') #如果路径分割前后有下划线也不要
  title = title.gsub('/_', '/')
  # 不知何时引入了多个连续的 // 可这 连续的 // 给我伤害
  # 哦，我知道何时引入的了，是ARGV[0]没有chomp掉目录的结尾 /
  title = title.gsub(/\/\/+/, '/')
  # 文件后缀前的下划线不要 text_.txt不对，应该是text.txt
  title = title.gsub(/_\./, '.')
  title = title.downcase
#  title = title.gsub(/srt$/i,'srt' ) # 为了后面匹配文件名后缀方便，都换成小写
#  title = title.gsub(/ass$/i,'ass' )
end
def recursive_rename(input, output)
  input = $input
  output = $output
  Dir.glob("#{input}/**/*").each do |file|
    next if File.directory? file
    # p file # file已经是展开的绝对目录了
    normalized_fn = $input + sanitize(file[$char_count_of_higher_path..-1])
    newfilename = normalized_fn.sub("#{$input}", "#{$output}") 
    # p normalized_fn
    # p newfilename
    path = File.dirname(normalized_fn)
    newpath = path.sub(input, output)
    FileUtils.mkdir_p(newpath) unless File.exist?(newpath)
    # p newpath
    # next unless newfilename =~ /(srt|ass)$/i
    FileUtils.cp(file, newfilename, :verbose => true)
  end  
end
recursive_rename($input, $output)

# begiin tests
# 现在每次运行这个脚本都会test一下
# 单独test还需要加上两个假的ARGV参数 ruby script.rb a b
class TestSanitize < MiniTest::Unit::TestCase

INPUT = '/home/WTF/got-me/input'
SIZE = INPUT.size
FILENAME = '/home/WTF/got-me/input/some-file_With-8*&^.txt'
  def test_sanitize
    assert_equal "this_is_a_title", sanitize('this is-a title ')
    assert_equal "经常_有_中_文_符_号", sanitize('经常@!有#中$文%&符*（号）')
    assert_equal "开头结尾有很多空格", sanitize('  开头结尾有很多空格   ')
    assert_equal "/home/WTF/got-me/input/some_file_with_8.txt", INPUT + sanitize(FILENAME[SIZE..-1]), 'FIXME: do not sanitize root folder!'
  end

end
